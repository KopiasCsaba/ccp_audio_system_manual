<!DOCTYPE html>
<html lang="en">
<head>
    <script>
        const WS_PASS = 'WoodenTableWithPineapple';
        const WS_HOST = '192.168.2.118';
    </script>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CCP Remote</title>
    <script src="https://unpkg.com/obs-websocket-js"></script>
    <style>
        body {
            font-family: Arial, serif;
        }

        #buttons-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 10px;
        }

        .sceneBtn hr {
            height: 1px;
            border: none;
            border-top: 1px solid black;
            margin: 2px 0px 2px 0px;
        }

        .sceneBtn {
            height: 60px;
            font-size: 15px;
            cursor: pointer;
            background-color: white;
            color: black;
            font-weight: normal;
            border: 1px solid black;
            border-radius: 5px;
            -webkit-transition: none;
            -moz-transition: none;
            -o-transition: none;
            transition: none;
        }

        .doubleWide {
            grid-column: span 2;
        }

        .eventScene {
            background-color: #fac0c0;
        }

        .camToggle {
            background: #ff00ff;
        }

        .newRow {
            grid-column: 1 / -1;
        }

        h4 {
            margin-top: 0px;
            margin-bottom: 4px;
        }
    </style>
</head>
<body>
<h4>OBS Remote (<span id="connection-status">disconnected</span>)</h4>
<div id="buttons-container"></div>
<script>
    const hotkeyButtons = {
        "<b>SCENE</b><hr>Projector Canvas": {"type": "sceneToPreview", "className": "sceneBtn", "data": {"sceneId": 15}},
        "<b>SCENE</b><hr>Pulpit Wide": {"type": "sceneToPreview", "className": "sceneBtn", "data": {"sceneId": 14}},
        "<b>SCENE</b><hr>Stage": {"type": "sceneToPreview", "className": "sceneBtn", "data": {"sceneId": 12}},
        "<b>SCENE</b><hr>Sitting": {"type": "sceneToPreview", "className": "sceneBtn", "data": {"sceneId": 11}},
        "<b>SCENE</b><hr>Custom Angle": {"type": "sceneToPreview", "className": "sceneBtn", "data": {"sceneId": 10}},
        "<b>SCENE</b><hr>Standby": {"type": "sceneToPreview", "className": "sceneBtn", "data": {"sceneId": 6}},
        "<b>SCENE</b><hr>PRE STREAM": {"type": "sceneToPreview", "className": "sceneBtn eventScene", "data": {"sceneId": 5}},
        "<b>SCENE</b><hr>BREAK": {"type": "sceneToPreview", "className": "sceneBtn eventScene", "data": {"sceneId": 4}},
        "<b>SCENE</b><hr>FINISH": {"type": "sceneToPreview", "className": "sceneBtn eventScene", "data": {"sceneId": 7}},
        "<b>TRANSITION</b>": {"type": "hotkey", "className": "sceneBtn transition", "data": {"on": "OBSBasic.Transition", "off": "OBSBasic.Transition"}, "confirm": true},
        "<b>CAM TOGGLE</b>": {"type": "hotkey", "className": "sceneBtn camToggle doubleWide", "data": {"on": "libobs.show_scene_item.20", "off": "libobs.hide_scene_item.20"}},
    };

    // Initialize the OBS WebSocket
    let obs;
    const reconnectTimeout = 5000; // 5 seconds
    let scenes = {}; // Store scenes globally to access later
    let versionInterval; // Store interval ID for the OBS version fetch
    let retryInterval = null; // Store interval ID for the OBS version fetch

    function initializeOBS() {
        console.log('Connecting...');
        obs = new OBSWebSocket();
        obs.on('ConnectionClosed', handleConnectionClosed);
    }

    async function connectOBS() {
        try {
            initializeOBS();
            // Connect to OBS WebSocket
            await obs.connect('ws://' + WS_HOST + ':4455', WS_PASS);

            clearInterval(retryInterval);
            retryInterval = null;

            console.log('Connected to OBS WebSocket');
            document.getElementById('connection-status').textContent = 'connected';

            // Fetch hotkeys
            const hotkeysResponse = await obs.call('GetHotkeyList');
            const hotkeys = hotkeysResponse.hotkeys;
            console.log("HOTKEYS", hotkeys);

            // Fetch scenes
            const scenesResponse = await obs.call('GetSceneList');
            scenes = {};
            for (const s of scenesResponse.scenes) {
                scenes[s.sceneName] = s.sceneIndex;
            }
            console.log("SCENES", scenes);

            // Fetch scene items for each scene
            const sceneItems = {};
            for (const scene of Object.keys(scenes)) {
                const itemsResponse = await obs.call('GetSceneItemList', {sceneName: scene});
                for (const item of itemsResponse.sceneItems) {
                    sceneItems[item.sourceName] = item.sceneItemId;
                }
            }
            console.log("ITEMS", sceneItems);

            // Create buttons for each hotkey defined in hotkeyButtons
            createHotkeyButtons();

            startFetchingOBSVersion();


        } catch (error) {
            handleConnectionClosed(error);
        }
    }

    function handleConnectionClosed(error) {
        if (retryInterval == null) {

            clearInterval(versionInterval);
            console.warn('OBS WebSocket connection closed. Reconnecting...', error);
            document.getElementById('connection-status').textContent = 'disconnected, reconnecting...';
            obs.disconnect();
            retryInterval = setInterval(connectOBS, reconnectTimeout);
        }
    }

    function startFetchingOBSVersion() {
        // Clear any existing interval to prevent multiple intervals running
        if (versionInterval) {
            clearInterval(versionInterval);
        }

        // Set an interval to fetch OBS version every 5 seconds
        versionInterval = setInterval(async () => {
            console.log("startFetchingOBSVersion");
            try {
                const versionResponse = await obs.call('GetVersion');
                console.log(`OBS Version: ${versionResponse.obsVersion}`);
            } catch (error) {
                handleConnectionClosed(error);
            }
        }, 5000);
    }

    function createHotkeyButtons() {
        const container = document.getElementById('buttons-container');
        container.innerHTML = '';

        for (const [key, value] of Object.entries(hotkeyButtons)) {
            const button = document.createElement('button');
            button.innerHTML = key;
            button.className = value.className || 'sceneBtn';

            button.addEventListener('click', async () => {
                const plainTextKey = key.replace(/<[^>]*>/g, '');  // Strip HTML tags from the key
                try {
                    if (value.confirm && !confirm(`Are you sure to execute '${plainTextKey}'?`)) {
                        return;
                    }

                    if (value.type === 'hotkey') {
                        const hotkeyToExecute = button.dataset.state === 'off' && value.data.off ? value.data.on : value.data.off;
                        if (hotkeyToExecute) {
                            await obs.call('TriggerHotkeyByName', {hotkeyName: hotkeyToExecute});
                            console.log(`Executed hotkey: ${hotkeyToExecute}`);

                            // Toggle the button state if "off" is defined
                            if (value.data.off) {
                                button.dataset.state = button.dataset.state === 'off' ? 'on' : 'off';
                            }
                        }
                    } else if (value.type === 'sceneToPreview') {
                        const sceneName = Object.keys(scenes).find(key => scenes[key] === value.data.sceneId);
                        if (sceneName) {
                            await obs.call('SetCurrentPreviewScene', {sceneName});
                            console.log(`Set scene to preview: ID ${value.data.sceneId}`);
                        }
                    }
                } catch (error) {
                    handleConnectionClosed(error);
                }
            });

            container.appendChild(button);
        }
    }

    // Connect to OBS WebSocket when the page loads
    connectOBS();
</script>
</body>
</html>
